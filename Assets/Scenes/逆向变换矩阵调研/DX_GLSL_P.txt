DX_Projection
1.357995	0	0	0
    0	-2.414213	0	0
    0	0	4.166365e-05	0.2500104
    0	0	-1	0


GLSL_Projection_Transpose
1.358,   0.00,    0.00,     0.00           
0.00,    2.41421, 0.00,     0.00         
0.00088, 0.00023, -1.00008, -1.00 
0.00,    0.00,    -0.50002, 0.00   

GLSL_Projection
1.358, 0.00,    0.00088,   0.00
0.00,  2.41421, 0.00023,   0.00
0.00,  0.00,    -1.00008,  -0.50002
0.00,  0.00,    -1.00,     0.00 


求 M 使得

DX_Projection = M*GLSL_Projection

则 M = DX_Projection*GLSL_Projection^-1


GLSL_Projection^-1
0.7364   	0.0000   	0.0000   	0.0006   
0.0000   	0.4142   	0.0000   	0.0001   
0.0000   	0.0000   	0.0000   	-1.0000   
0.0000   	0.0000   	-1.9999   	2.0001   


M = DX_Projection*GLSL_Projection^-1
1.0000   	0.0000   	0.0000   	0.0008   
0.0000   	-1.0000   	0.0000   	-0.0002   
0.0000   	0.0000   	-0.5000   	0.5000   
0.0000   	0.0000   	0.0000   	1.0000  
≈
1.0000   	0.0000   	0.0000   	0.0000   
0.0000     -1.0000   	0.0000   	0.0000   
0.0000   	0.0000     -0.5000      0.5000   
0.0000   	0.0000   	0.0000   	1.0000

即 M_GlslP_to_DxP
// y' = -y              // 上下颠倒
// z' = -0.5*z + 0.5*w  // 近到远：-w~+w => 0.5w + 0.5w ~ -0.5w + 0.5w => w~0
1,    0,    0,    0
0,   -1,    0,    0
0,    0, -0.5,  0.5   
0,    0,    0,    1

则 M_DxP_to_GlslP = M_GlslP_to_DxP^-1
1.0000   	0.0000   	0.0000   	0.0000   
-0.0000   	-1.0000   	-0.0000   	-0.0000   
-0.0000   	-0.0000   	-2.0000   	1.0000   
0.0000   	0.0000   	0.0000   	1.0000 

即 M_DxP_to_GlslP
// y' = -y              // 上下颠倒
// z' = -2*z + w        // 近到远：w~0 => -2w+w ~ w => -w~w
1,    0,    0,    0
0,   -1,    0,    0
0,    0,   -2,    1
0,    0,    0,    1


vec4 GlslToDxClipPos(vec4 clipPos) {
    clipPos.y = -clipPos.y;
    clipPos.z = -0.5*clipPos.z + 0.5*clipPos.w;
    return clipPos;
}

vec4 DxToGlslClipPos(vec4 clipPos) {
    clipPos.y = -clipPos.y;
    clipPos.z = -2*clipPos.z + clipPos.w;
    return clipPos;
}